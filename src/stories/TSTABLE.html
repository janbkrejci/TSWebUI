<div class="sl-theme-{{theme}} base-container main-container">
    <script src="/table-data.js"></script>
    <script src="/column-definitions.js"></script>
    <script>
        // Pagination state
        var currentPage = 1;
        var itemsPerPage = 5;
        var availablePageSizes = [5, 10, 20, 50, 100];

        // Column filtering state
        var columnFilters = {}; // Object to store active filters by column key
        var filteredData = []; // Cached filtered data
        var filterTimeout = null; // Timeout for debouncing
        var FILTER_DEBOUNCE_DELAY = 500; // Half second debounce

        // Row selection state
        var selectedRowIds = new Set();
        // Selection view mode for filtering by selection
        // Possible values: 'all' | 'selected' | 'unselected'
        var selectionViewMode = 'all';

        // Row menu actions configuration
        var menuActions = [
            { actionName: 'edit', label: 'Edit' },
            { actionName: 'duplicate', label: 'Duplicate' },
            { actionName: 'delete', label: 'Delete' },
            { actionName: 'view_details', label: 'View Details' },
            { actionName: 'export', label: 'Export Row' }
        ];

        // Function to handle row menu item selection
        function rowMenuItemSelected(menuAction, rowData) {
            console.log('Selected action:', menuAction, 'for row:', rowData);
        }

        // Column visibility configuration
        var preselectedColumns = ['name', 'email', 'turnover', 'contractDate', 'approved'];
        var unhideableColumns = ['name', 'email'];
        var unshowableColumns = ['id']; // These columns are hidden and cannot be shown in column selection menu

        // Function to get visible columns based on column definitions, sorted by order
        function getVisibleColumns() {
            return columnDefinitions
                .filter(col => col.visible)
                .sort((a, b) => a.order - b.order);
        }

        // Function to move column left in order
        function moveColumnLeft(columnKey) {
            const currentCol = columnDefinitions.find(col => col.key === columnKey);
            if (!currentCol) return;

            // Find the visible column that is immediately to the left
            const visibleColumns = getVisibleColumns();
            const currentIndex = visibleColumns.findIndex(col => col.key === columnKey);

            if (currentIndex > 0) {
                const leftCol = visibleColumns[currentIndex - 1];
                // Swap order values
                const tempOrder = currentCol.order;
                currentCol.order = leftCol.order;
                leftCol.order = tempOrder;

                // Refresh table and menu
                populateTable();
                const columnSelector = document.getElementById('column-selector');
                if (columnSelector) columnSelector.refreshMenu();
            }
        }

        // Function to move column right in order
        function moveColumnRight(columnKey) {
            const currentCol = columnDefinitions.find(col => col.key === columnKey);
            if (!currentCol) return;

            // Find the visible column that is immediately to the right
            const visibleColumns = getVisibleColumns();
            const currentIndex = visibleColumns.findIndex(col => col.key === columnKey);

            if (currentIndex < visibleColumns.length - 1) {
                const rightCol = visibleColumns[currentIndex + 1];
                // Swap order values
                const tempOrder = currentCol.order;
                currentCol.order = rightCol.order;
                rightCol.order = tempOrder;

                // Refresh table and menu
                populateTable();
                const columnSelector = document.getElementById('column-selector');
                if (columnSelector) columnSelector.refreshMenu();
            }
        }

        // ---- Sorting helpers ----
        function getActiveSortColumn() {
            // Prefer first VISIBLE sortable column with active sort, ordered by 'order'
            const visibleActive = columnDefinitions
                .filter(c => c.visible && c.sortable && c.sortDirection && c.sortDirection !== 'none')
                .sort((a, b) => a.order - b.order);
            if (visibleActive.length > 0) return visibleActive[0];

            // Fallback: any active sortable column
            const anyActive = columnDefinitions.find(c => c.sortable && c.sortDirection && c.sortDirection !== 'none');
            return anyActive || null;
        }

        function clearOtherSorts(exceptKey) {
            columnDefinitions.forEach(c => {
                if (c.key !== exceptKey) c.sortDirection = 'none';
            });
        }

        // ---- Date Range Parsing Functions ----
        
        /**
         * Parses date range filter input and returns start and end dates
         * @param {string} input - The filter input string
         * @returns {Array<Date|null>} - Array of [startDate, endDate] or [null, null] if unparseable
         */
        function parseDateRange(input) {
            if (!input || typeof input !== 'string') {
                return [null, null];
            }

            let trimmed = input.trim();
            if (!trimmed) {
                return [null, null];
            }

            // Normalize date separators: convert / and - to periods
            trimmed = trimmed.replace(/[\/\-]/g, '.');

            // Check for invalid input patterns
            // 1. Input cannot start or end with a period (except for range notation "..")
            if ((trimmed.startsWith('.') && !trimmed.startsWith('..')) || 
                (trimmed.endsWith('.') && !trimmed.endsWith('..'))) {
                return [new Date('2099-12-31'), new Date('1900-01-01')]; // Unsatisfyable range
            }

            // 2. Check for months or days with more than 2 digits
            // Split by range notation first, then check each part
            const rangeParts = trimmed.split('..');
            for (let rangePart of rangeParts) {
                if (rangePart) {
                    const dateParts = rangePart.split('.');
                    for (let i = 0; i < dateParts.length; i++) {
                        const part = dateParts[i].trim();
                        if (part && /^\d+$/.test(part)) {
                            // For 4-digit years, allow them (typically position 0 for yyyy format, or last position for dd.mm.yyyy)
                            const isLikelyYear = part.length === 4;
                            // For non-year parts (months/days), maximum 2 digits
                            if (!isLikelyYear && part.length > 2) {
                                return [new Date('2099-12-31'), new Date('1900-01-01')]; // Unsatisfyable range
                            }
                        }
                    }
                }
            }

            // 2. More than two subsequent periods (e.g., "...", "....")
            if (/\.{3,}/.test(trimmed)) {
                return [new Date('2099-12-31'), new Date('1900-01-01')]; // Unsatisfyable range
            }
            
            // 3. More than one sequence of two periods (e.g., "2020..2021..2022")
            const doublePeriodMatches = trimmed.match(/\.\./g);
            if (doublePeriodMatches && doublePeriodMatches.length > 1) {
                return [new Date('2099-12-31'), new Date('1900-01-01')]; // Unsatisfyable range
            }

            try {
                // Handle range patterns with ".."
                if (trimmed.includes('..')) {
                    const parts = trimmed.split('..');
                    
                    // Handle patterns like "..yyyy" or "..dd.mm.yyyy" (before or at)
                    if (parts[0] === '' && parts[1]) {
                        const endDate = parseSingleDate(parts[1], 'end');
                        return [null, endDate];
                    }
                    
                    // Handle patterns like "yyyy.." or "dd.mm.yyyy.." (after or at)
                    if (parts[1] === '' && parts[0]) {
                        const startDate = parseSingleDate(parts[0], 'start');
                        return [startDate, null];
                    }
                    
                    // Handle patterns like "yyyy..yyyy" or "dd.mm.yyyy..dd.mm.yyyy" (between)
                    if (parts[0] && parts[1]) {
                        const startDate = parseSingleDate(parts[0], 'start');
                        const endDate = parseSingleDate(parts[1], 'end');
                        return [startDate, endDate];
                    }
                }

                // Handle single date/period patterns
                const singleDate = parseSingleDate(trimmed, 'both');
                if (singleDate && singleDate.start && singleDate.end) {
                    return [singleDate.start, singleDate.end];
                }

                return [null, null];
            } catch (error) {
                return [null, null];
            }
        }

        /**
         * Parses a single date specification
         * @param {string} dateStr - Date string (yyyy, mm.yyyy, dd.mm.yyyy)
         * @param {string} mode - 'start', 'end', or 'both'
         * @returns {Date|Object} - Date for start/end modes, {start, end} for both mode
         */
        function parseSingleDate(dateStr, mode = 'both') {
            const parts = dateStr.split('.');
            
            if (parts.length === 1) {
                // Format: yyyy
                const year = parseInt(parts[0]);
                if (isNaN(year) || year < 1900 || year > 2100) return null;
                
                const startDate = new Date(year, 0, 1); // January 1st
                const endDate = new Date(year, 11, 31, 23, 59, 59, 999); // December 31st
                
                if (mode === 'start') return startDate;
                if (mode === 'end') return endDate;
                return { start: startDate, end: endDate };
            }
            
            if (parts.length === 2) {
                // Format: mm.yyyy
                const month = parseInt(parts[0]);
                const year = parseInt(parts[1]);
                
                if (isNaN(month) || isNaN(year) || month < 1 || month > 12 || year < 1900 || year > 2100) {
                    return null;
                }
                
                const startDate = new Date(year, month - 1, 1); // First day of month
                const endDate = new Date(year, month, 0, 23, 59, 59, 999); // Last day of month
                
                if (mode === 'start') return startDate;
                if (mode === 'end') return endDate;
                return { start: startDate, end: endDate };
            }
            
            if (parts.length === 3) {
                // Format: dd.mm.yyyy
                const day = parseInt(parts[0]);
                const month = parseInt(parts[1]);
                const year = parseInt(parts[2]);
                
                if (isNaN(day) || isNaN(month) || isNaN(year) || 
                    day < 1 || day > 31 || month < 1 || month > 12 || year < 1900 || year > 2100) {
                    return null;
                }
                
                const startDate = new Date(year, month - 1, day); // Start of day
                const endDate = new Date(year, month - 1, day, 23, 59, 59, 999); // End of day
                
                if (mode === 'start') return startDate;
                if (mode === 'end') return endDate;
                return { start: startDate, end: endDate };
            }
            
            return null;
        }

        /**
         * Checks if a date is within the specified range
         * @param {Array<Date|null>} range - Array of [startDate, endDate]
         * @param {Date|string} dateValue - The date to check
         * @returns {boolean} - True if date is in range
         */
        function isInDateRange(range, dateValue) {
            if (!range || range.length !== 2) return false;
            
            const [startDate, endDate] = range;
            
            // Convert dateValue to Date object if it's a string
            let targetDate;
            if (typeof dateValue === 'string') {
                targetDate = new Date(dateValue);
            } else if (dateValue instanceof Date) {
                targetDate = dateValue;
            } else {
                return false;
            }
            
            // Check if target date is valid
            if (isNaN(targetDate.getTime())) return false;
            
            // Check range conditions
            if (startDate && endDate) {
                // Between start and end (inclusive)
                return targetDate >= startDate && targetDate <= endDate;
            } else if (startDate) {
                // On or after start date
                return targetDate >= startDate;
            } else if (endDate) {
                // On or before end date
                return targetDate <= endDate;
            }
            
            // No range specified
            return false;
        }

        // ---- Number Range Parsing Functions ----
        
        /**
         * Parses number range filter input and returns min and max values
         * @param {string} input - The filter input string
         * @returns {Array<number|null>} - Array of [minValue, maxValue] or [null, null] if unparseable
         */
        function parseNumberRange(input) {
            if (!input || typeof input !== 'string') {
                return [null, null];
            }

            const trimmed = input.trim();
            if (!trimmed) {
                return [null, null];
            }

            // Check for invalid period sequences
            // 1. More than two subsequent periods (e.g., "...", "....")
            if (/\.{3,}/.test(trimmed)) {
                return [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]; // Unsatisfyable range
            }
            
            // 2. More than one sequence of two periods (e.g., "100..200..300")
            const doublePeriodMatches = trimmed.match(/\.\./g);
            if (doublePeriodMatches && doublePeriodMatches.length > 1) {
                return [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]; // Unsatisfyable range
            }

            try {
                // Handle range patterns with ".."
                if (trimmed.includes('..')) {
                    const parts = trimmed.split('..');
                    
                    // Handle patterns like "..1000" (less than or equal to)
                    if (parts[0] === '' && parts[1]) {
                        const maxValue = parseNumber(parts[1]);
                        return [null, maxValue];
                    }
                    
                    // Handle patterns like "1000.." (greater than or equal to)
                    if (parts[1] === '' && parts[0]) {
                        const minValue = parseNumber(parts[0]);
                        return [minValue, null];
                    }
                    
                    // Handle patterns like "1000..5000" (between)
                    if (parts[0] && parts[1]) {
                        const minValue = parseNumber(parts[0]);
                        const maxValue = parseNumber(parts[1]);
                        return [minValue, maxValue];
                    }
                }

                // Handle single number - exact match or contains
                const singleNumber = parseNumber(trimmed);
                if (singleNumber !== null) {
                    // For exact matching, we'll use a small epsilon for floating point comparison
                    return [singleNumber, singleNumber];
                }

                return [null, null];
            } catch (error) {
                return [null, null];
            }
        }

        /**
         * Parses a number string with flexible formatting
         * @param {string} numberStr - Number string with potential spaces and different decimal separators
         * @returns {number|null} - Parsed number or null if invalid
         */
        function parseNumber(numberStr) {
            if (!numberStr || typeof numberStr !== 'string') {
                return null;
            }

            try {
                // Remove all spaces
                let cleaned = numberStr.replace(/\s/g, '');
                
                // Handle empty string after cleaning
                if (!cleaned) {
                    return null;
                }
                
                // Replace comma with dot for decimal separator
                cleaned = cleaned.replace(',', '.');
                
                // Handle trailing decimal separator (e.g., "1000." should become "1000")
                if (cleaned.endsWith('.')) {
                    cleaned = cleaned.slice(0, -1);
                }
                
                // Validate that we have a valid number format
                // Allow optional minus sign, digits, optional decimal point and digits
                if (!/^-?\d+(\.\d+)?$/.test(cleaned)) {
                    return null;
                }
                
                const parsed = parseFloat(cleaned);
                
                // Check if parsing was successful
                if (isNaN(parsed)) {
                    return null;
                }
                
                return parsed;
            } catch (error) {
                return null;
            }
        }

        /**
         * Checks if a number is within the specified range
         * @param {Array<number|null>} range - Array of [minValue, maxValue]
         * @param {number|string} numberValue - The number to check
         * @returns {boolean} - True if number is in range
         */
        function isInNumberRange(range, numberValue) {
            if (!range || range.length !== 2) return false;
            
            const [minValue, maxValue] = range;
            
            // Convert numberValue to number if it's a string
            let targetNumber;
            if (typeof numberValue === 'string') {
                targetNumber = parseNumber(numberValue);
            } else if (typeof numberValue === 'number') {
                targetNumber = numberValue;
            } else {
                return false;
            }
            
            // Check if target number is valid
            if (targetNumber === null || isNaN(targetNumber)) return false;
            
            // Check range conditions
            if (minValue !== null && maxValue !== null) {
                // Between min and max (inclusive)
                if (minValue === maxValue) {
                    // Exact match - use small epsilon for floating point comparison
                    const epsilon = 1e-10;
                    return Math.abs(targetNumber - minValue) < epsilon;
                } else {
                    return targetNumber >= minValue && targetNumber <= maxValue;
                }
            } else if (minValue !== null) {
                // Greater than or equal to min
                return targetNumber >= minValue;
            } else if (maxValue !== null) {
                // Less than or equal to max
                return targetNumber <= maxValue;
            }
            
            // No range specified
            return false;
        }

        // ---- Text Pattern Matching Functions ----
        
        /**
         * Checks if text matches a pattern with wildcard support
         * @param {string} pattern - Pattern with * wildcards, ** for literal *, . prefix for start-of-string match
         * @param {string} text - Text to match against
         * @returns {boolean} - True if text matches the pattern
         */
        function matchTextPattern(pattern, text) {
            if (!pattern || typeof pattern !== 'string') return true;
            if (!text || typeof text !== 'string') return false;
            
            // Normalize to lowercase for Czech locale case-insensitive comparison
            const normalizedPattern = pattern.toLowerCase();
            const normalizedText = text.toLowerCase();
            
            // Handle start-of-string matching (pattern begins with .)
            let isStartMatch = false;
            let workingPattern = normalizedPattern;
            
            if (normalizedPattern.startsWith('.')) {
                isStartMatch = true;
                workingPattern = normalizedPattern.substring(1);
            }
            
            // Convert pattern to regex
            const regexPattern = convertPatternToRegex(workingPattern);
            
            if (isStartMatch) {
                // Match must be at the beginning
                return new RegExp('^' + regexPattern).test(normalizedText);
            } else {
                // Match can be anywhere
                return new RegExp(regexPattern).test(normalizedText);
            }
        }
        
        /**
         * Converts a wildcard pattern to a regex pattern
         * @param {string} pattern - Pattern with * wildcards and ** for literal *
         * @returns {string} - Regex pattern string
         */
        function convertPatternToRegex(pattern) {
            // Escape special regex characters except * which we'll handle specially
            let escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
            
            // Handle ** (literal asterisk) - replace with placeholder
            escaped = escaped.replace(/\*\*/g, '###LITERAL_ASTERISK###');
            
            // Handle * (wildcard) - replace with .*
            escaped = escaped.replace(/\*/g, '.*');
            
            // Restore literal asterisks
            escaped = escaped.replace(/###LITERAL_ASTERISK###/g, '\\*');
            
            return escaped;
        }

        function toggleSort(columnKey) {
            const col = columnDefinitions.find(c => c.key === columnKey);
            if (!col || !col.sortable) return;

            // Cycle: none -> asc -> desc -> none
            const next = col.sortDirection === 'none' || !col.sortDirection
                ? 'asc'
                : col.sortDirection === 'asc'
                    ? 'desc'
                    : 'none';

            col.sortDirection = next;
            // Single-column sort: clear others
            clearOtherSorts(col.key);

            // Keep current page but ensure rows + headers reflect sort
            createTableHeaders();
            populateTableRows();
            updatePaginationUI();
        }

        // ---- Column Resize Logic ----
        var isResizing = false;
        var resizeColKey = null;
        var startX = 0;
    var startWidth = 0;
    var lastResizeEnd = 0;

        function getColumnDefByKey(key) {
            return columnDefinitions.find(c => c.key === key);
        }

        function onResizerDown(e) {
            const handle = e.target.closest('.col-resizer');
            if (!handle) return;
            const key = handle.getAttribute('data-column-key');
            if (!key) return;

            const colDef = getColumnDefByKey(key);
            if (!colDef) return;

            // Compute current width of the corresponding col element or header cell
            const table = document.getElementById('data-table');
            const colEl = table?.querySelector(`col[data-column-key="${key}"]`);
            const th = handle.closest('th');
            const currentWidth = (colEl?.offsetWidth || th?.offsetWidth || 150);

            isResizing = true;
            resizeColKey = key;
            startX = (e.touches?.[0]?.clientX ?? e.clientX);
            startWidth = currentWidth;

            document.body.classList.add('col-resizing');
            handle.classList.add('active');
            document._activeColResizer = handle;
            e.preventDefault();
            e.stopPropagation();
        }

        function onResizerMove(e) {
            if (!isResizing || !resizeColKey) return;
            const clientX = (e.touches?.[0]?.clientX ?? e.clientX);
            const dx = clientX - startX;
            const minWidth = 60; // minimal practical width
            const newWidth = Math.max(minWidth, Math.round(startWidth + dx));
            const colDef = getColumnDefByKey(resizeColKey);
            if (!colDef) return;
            colDef.width = newWidth; // persist
            rebuildColgroup();
        }

        function onResizerUp() {
            if (!isResizing) return;
            isResizing = false;
            resizeColKey = null;
            document.body.classList.remove('col-resizing');
            if (document._activeColResizer) {
                document._activeColResizer.classList.remove('active');
                document._activeColResizer = null;
            }
            lastResizeEnd = performance.now();
        }

        function wireResizers(theadEl) {
            const resizers = theadEl.querySelectorAll('.col-resizer');
            resizers.forEach(h => {
                // mouse
                h.addEventListener('mousedown', onResizerDown, { passive: false });
                // touch
                h.addEventListener('touchstart', onResizerDown, { passive: false });
                // double click -> auto-fit
                h.addEventListener('dblclick', (e) => {
                    const key = h.getAttribute('data-column-key');
                    if (!key) return;
                    autoFitColumnWidth(key);
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            // Global listeners (add once)
            if (!document._colResizeWired) {
                document.addEventListener('mousemove', onResizerMove, { passive: true });
                document.addEventListener('mouseup', onResizerUp, { passive: true });
                document.addEventListener('touchmove', onResizerMove, { passive: false });
                document.addEventListener('touchend', onResizerUp, { passive: true });
                document._colResizeWired = true;
            }
        }

        // Header-wide hover sync: highlight arrows and both resizers when pointer is in any header row cell of a column
        function setupTheadHover(theadEl) {
            let lastKey = null;
            const clear = () => {
                // remove resizer hover classes
                theadEl.querySelectorAll('.col-resizer.hover').forEach(el => el.classList.remove('hover'));
                // remove header th column-hover
                theadEl.querySelectorAll('th.column-hover').forEach(th => th.classList.remove('column-hover'));
                lastKey = null;
            };
            const applyForKey = (key) => {
                if (!key) return;
                // mark header th for this key
                const headerTh = theadEl.querySelector(`th[data-column-key="${key}"]`);
                if (headerTh) headerTh.classList.add('column-hover');
                // highlight resizer
                theadEl.querySelectorAll(`.col-resizer[data-column-key="${key}"]`).forEach(el => el.classList.add('hover'));
            };
            theadEl.addEventListener('mousemove', (e) => {
                // find th with data-column-key
                const th = e.target.closest('th[data-column-key]');
                const withinThead = th && theadEl.contains(th);
                if (!withinThead) { clear(); return; }
                const key = th.getAttribute('data-column-key');
                if (!key || key === lastKey) return;
                clear();
                lastKey = key;
                applyForKey(key);
            });
            theadEl.addEventListener('mouseleave', clear);
        }

        // Auto-fit width by content (entire dataset + header)
        function autoFitColumnWidth(columnKey) {
            const table = document.getElementById('data-table');
            if (!table) return;
            const minWidth = 60;
            const maxWidth = 600; // prevent extreme expansion

            // Measure header content width
            const th = table.querySelector(`thead th[data-column-key="${columnKey}"] .column-header-content`);
            let headerWidth = 0;
            if (th) {
                const tmp = th.cloneNode(true);
                tmp.style.position = 'absolute';
                tmp.style.visibility = 'hidden';
                tmp.style.whiteSpace = 'nowrap';
                document.body.appendChild(tmp);
                headerWidth = Math.ceil(tmp.getBoundingClientRect().width) + 20; // include padding and sort icon
                document.body.removeChild(tmp);
            }

            // Measure values from entire dataset for this column
            const colIndex = getVisibleColumns().findIndex(c => c.key === columnKey);
            if (colIndex < 0) return;
            const visibleCols = getVisibleColumns();
            const columnDef = visibleCols[colIndex];
            const measureContainer = document.createElement('div');
            measureContainer.style.position = 'absolute';
            measureContainer.style.left = '-99999px';
            measureContainer.style.top = '0';
            measureContainer.style.visibility = 'hidden';
            document.body.appendChild(measureContainer);

            const sampleTd = table.querySelector('tbody td');
            const sampleFont = sampleTd ? getComputedStyle(sampleTd).font : getComputedStyle(document.body).font;
            let maxCell = 0;
            const formatter = (val) => {
                // approximate rendering for special columns
                if (columnDef.key === 'turnover' && typeof val === 'number') {
                    // emulate 2-decimal formatting
                    return val.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                }
                if (columnDef.key === 'contractDate' && typeof val === 'string') {
                    // format as short date
                    try { return new Date(val).toLocaleDateString(); } catch { return val; }
                }
                if (columnDef.key === 'approved') {
                    return val ? 'Zapnuto' : 'Vypnuto'; // switch proxy width
                }
                return (val ?? '').toString();
            };
            for (const row of tableData) {
                const text = formatter(row[columnKey]);
                const el = document.createElement('div');
                el.style.whiteSpace = 'nowrap';
                el.style.font = sampleFont;
                el.textContent = text;
                measureContainer.appendChild(el);
                const w = Math.ceil(el.getBoundingClientRect().width) + 28; // padding + buffer
                if (w > maxCell) maxCell = w;
                measureContainer.removeChild(el);
            }
            document.body.removeChild(measureContainer);

            const newWidth = Math.min(maxWidth, Math.max(minWidth, Math.max(headerWidth, maxCell)));
            const colDef = getColumnDefByKey(columnKey);
            if (colDef) {
                colDef.width = newWidth;
                rebuildColgroup();
            }
        }

        function compareValues(aVal, bVal) {
            const aNull = aVal === null || aVal === undefined;
            const bNull = bVal === null || bVal === undefined;
            if (aNull && bNull) return 0;
            if (aNull) return 1; // nulls last
            if (bNull) return -1;

            if (typeof aVal === 'number' && typeof bVal === 'number') {
                return aVal - bVal;
            }

            // String compare (case-insensitive, numeric aware)
            return String(aVal).localeCompare(String(bVal), undefined, { numeric: true, sensitivity: 'base' });
        }

        function getSortedData(data) {
            const activeCol = getActiveSortColumn();
            if (!activeCol || activeCol.sortDirection === 'none') return data;

            const key = activeCol.key;
            const dir = activeCol.sortDirection;
            const sorted = data.slice().sort((a, b) => {
                const cmp = compareValues(a[key], b[key]);
                return dir === 'asc' ? cmp : -cmp;
            });
            return sorted;
        }

        // Column filtering functions
        function showLoadingOverlay() {
            const overlay = document.getElementById('table-loading-overlay');
            const table = document.getElementById('data-table');

            if (overlay && table) {
                const thead = table.querySelector('thead');

                if (thead) {
                    // Calculate the height of thead to position overlay correctly
                    const theadHeight = thead.offsetHeight;
                    overlay.style.top = theadHeight + 'px';
                }

                overlay.classList.remove('hidden');
                overlay.classList.add('visible');
            }
        }

        function hideLoadingOverlay() {
            const overlay = document.getElementById('table-loading-overlay');
            if (overlay) {
                overlay.classList.remove('visible');
                overlay.classList.add('hidden');
            }
            // Focus is automatically preserved since filter inputs are not regenerated
        }

        function applyFilters() {
            // Show loading overlay
            showLoadingOverlay();

            // Filter data based on active column filters
            filteredData = tableData.filter(row => {
                return Object.keys(columnFilters).every(columnKey => {
                    const filterValue = columnFilters[columnKey];
                    if (!filterValue) return true; // Empty filter passes all

                    const cellValue = row[columnKey];
                    if (cellValue === null || cellValue === undefined) return false;

                    // Get column definition for type-specific filtering
                    const column = columnDefinitions.find(col => col.key === columnKey);
                    
                    // Handle date column filtering with smart date ranges
                    if (column && column.type === 'date') {
                        const dateRange = parseDateRange(filterValue);
                        return isInDateRange(dateRange, cellValue);
                    }

                    // Handle number column filtering with smart number ranges
                    if (column && column.type === 'number') {
                        const numberRange = parseNumberRange(filterValue);
                        return isInNumberRange(numberRange, cellValue);
                    }

                    // Handle text column filtering with pattern matching (wildcards, case-insensitive)
                    return matchTextPattern(filterValue, cellValue.toString());
                });
            });

            // Reset to first page when filters change
            currentPage = 1;

            // Update only table rows and pagination (no need to regenerate headers)
            populateTableRows();
            updatePaginationUI();

            // Update column selector to refresh filter icons
            const columnSelector = document.getElementById('column-selector');
            if (columnSelector) {
                columnSelector.setColumnFilters(columnFilters);
            }

            // Hide loading overlay (focus is preserved since headers are not regenerated)
            hideLoadingOverlay();
        }

        function setColumnFilter(columnKey, filterValue) {
            // Clear existing timeout
            if (filterTimeout) {
                clearTimeout(filterTimeout);
            }

            // Update filter value
            if (filterValue && filterValue.trim()) {
                columnFilters[columnKey] = filterValue.trim();
            } else {
                delete columnFilters[columnKey];
            }

            // If clearing filter, apply immediately
            if (!filterValue || !filterValue.trim()) {
                applyFilters();
                return;
            }

            // Show loading overlay immediately when user starts typing
            showLoadingOverlay();

            // Debounce the filtering
            filterTimeout = setTimeout(() => {
                applyFilters();
            }, FILTER_DEBOUNCE_DELAY);
        }

        function clearAllFilters() {
            columnFilters = {};
            filteredData = [];

            // Clear all filter inputs
            const filterInputs = document.querySelectorAll('thead sl-input');
            filterInputs.forEach(input => {
                input.value = '';
            });

            // Clear all filter dropdowns (boolean columns)
            const filterDropdowns = document.querySelectorAll('thead sl-dropdown sl-button[data-column-key]');
            filterDropdowns.forEach(button => {
                // Reset to default state (show "Všechny")
                button.innerHTML = 'Všechny<sl-icon name="chevron-down" slot="suffix"></sl-icon>';
            });

            // Reset to first page and update table
            currentPage = 1;
            populateTableRows();
            updatePaginationUI();

            // Update column menu to refresh filter icons
            // createColumnsMenu(); // Removed - now handled by TSColumnSelector component
        }

        // ---- Row selection helpers ----
        function getHeaderCheckbox() {
            return document.getElementById('header-select-all');
        }

        function updateHeaderCheckboxState() {
            const headerCb = getHeaderCheckbox();
            if (!headerCb) return;
            const activeData = getActiveData();
            const total = activeData.length;
            if (total === 0) {
                headerCb.checked = false;
                headerCb.indeterminate = false;
                return;
            }
            let selectedCount = 0;
            for (const row of activeData) {
                if (selectedRowIds.has(row.id)) selectedCount++;
            }
            if (selectedCount === 0) {
                headerCb.checked = false;
                headerCb.indeterminate = false;
            } else if (selectedCount === total) {
                headerCb.checked = true;
                headerCb.indeterminate = false;
            } else {
                headerCb.checked = false;
                headerCb.indeterminate = true;
            }
        }

        function handleRowCheckboxChange(rowId, checked) {
            if (checked) {
                selectedRowIds.add(rowId);
            } else {
                selectedRowIds.delete(rowId);
            }
            updateHeaderCheckboxState();
            // If we are in a filtered-by-selection mode, re-render rows so that the row disappears/appears immediately
            if (selectionViewMode !== 'all') {
                populateTableRows();
                updatePaginationUI();
            }
            updateSelectionMenuUI();
            updateSelectionViewToggleUI();
        }

        function selectAllActive() {
            const activeData = getActiveData();
            activeData.forEach(row => selectedRowIds.add(row.id));
            updateSelectionMenuUI();
        }

        function deselectAllActive() {
            const activeData = getActiveData();
            activeData.forEach(row => selectedRowIds.delete(row.id));
            updateSelectionMenuUI();
        }

        function clearAllSelectedRecords() {
            selectedRowIds.clear();
            populateTableRows();
            updatePaginationUI();
            // Reset selection view mode and UI when no rows are selected
            selectionViewMode = 'all';
            updateSelectionViewToggleUI();
        }

        function handleHeaderCheckboxChange(event) {
            const checked = event.target.checked;
            if (checked) {
                selectAllActive();
            } else {
                deselectAllActive();
            }
            // Re-render current page checkboxes to reflect new state
            populateTableRows();
            updatePaginationUI();
            updateSelectionMenuUI();
        }

        function getSelectedRows() {
            return tableData.filter(r => selectedRowIds.has(r.id));
        }

        function updateSelectionMenuUI() {
            const selectionMenu = document.getElementById('selection-menu');
            if (!selectionMenu) return;

            const selectedCount = selectedRowIds.size;
            if (selectedCount > 0) {
                selectionMenu.show();
                selectionMenu.setSelectionCount(selectedCount);
                const selectedRows = tableData.filter(row => selectedRowIds.has(row.id));
                selectionMenu.setSelectedRows(selectedRows);
            } else {
                selectionMenu.hide();
            }
            // Keep the selection view toggle in sync
            updateSelectionViewToggleUI();
        }

        // Pagination functions
        function getActiveData() {
            // Base data: filtered or all
            const base = Object.keys(columnFilters).length > 0 ? filteredData : tableData;
            // Apply selection view mode filter on top
            if (selectionViewMode === 'selected') {
                return base.filter(r => selectedRowIds.has(r.id));
            }
            if (selectionViewMode === 'unselected') {
                return base.filter(r => !selectedRowIds.has(r.id));
            }
            return base;
        }

        function getTotalPages() {
            const activeData = getActiveData();
            return Math.ceil(activeData.length / itemsPerPage);
        }

        function getCurrentPageData() {
            const activeData = getActiveData();
            const sorted = getSortedData(activeData);
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            return sorted.slice(startIndex, endIndex);
        }

        function updatePaginationUI() {
            const footer = document.getElementById('table-footer');
            if (footer) {
                const activeData = getActiveData();
                footer.setAttribute('totalrecordscount', tableData.length);
                footer.setAttribute('filteredrecordscount', activeData.length);
                footer.setAttribute('pagesize', itemsPerPage);
                footer.setAttribute('pagesizes', JSON.stringify(availablePageSizes));
                footer.setAttribute('currentpage', currentPage);
            }
        }

        function goToPage(page) {
            const totalPages = getTotalPages();
            if (page >= 1 && page <= totalPages && page !== currentPage) {
                currentPage = page;
                populateTableRows();
                updatePaginationUI();
            }
        }

        function changeItemsPerPage(newSize) {
            // Prevent unnecessary rerendering if the same size is selected
            if (itemsPerPage === newSize) {
                return;
            }

            itemsPerPage = newSize;
            currentPage = 1; // Reset to first page
            populateTableRows();
            updatePaginationUI();
        }

        // Function to select all columns (respecting unhideable and unshowable columns)
        function selectAllColumns() {
            // Update column definitions
            columnDefinitions.forEach(col => {
                if (!unshowableColumns.includes(col.key)) {
                    col.visible = true;
                }
            });

            // Update column selector component
            const columnSelector = document.getElementById('column-selector');
            if (columnSelector) {
                columnSelector.setColumnDefinitions(columnDefinitions);
            }
            populateTable();
        }

        // Function to clear all columns (respecting unhideable columns, unshowable columns stay hidden)
        function clearAllColumns() {
            // Update column definitions (keep unshowable columns visible, unhideable columns stay hidden)
            columnDefinitions.forEach(col => {
                if (unshowableColumns.includes(col.key)) {
                    // Keep unshowable columns hidden
                    col.visible = false;
                } else if (!unhideableColumns.includes(col.key)) {
                    col.visible = false;
                }
            });

            // Update column selector component
            const columnSelector = document.getElementById('column-selector');
            if (columnSelector) {
                columnSelector.setColumnDefinitions(columnDefinitions);
            }
            populateTable();
        }

        // Track open dropdown for overlay management
        var currentOpenDropdown = null;

        // Initialize overlay event listener
        function initializeDropdownOverlay() {
            const overlay = document.getElementById('dropdown-overlay');
            if (overlay) {
                overlay.addEventListener('click', () => {
                    if (currentOpenDropdown) {
                        currentOpenDropdown.hide();
                    }
                });
            }
        }

        // Show overlay
        function showDropdownOverlay() {
            const overlay = document.getElementById('dropdown-overlay');
            if (overlay) {
                overlay.classList.remove('hidden');
                overlay.classList.add('visible');
            }
        }

        // Hide overlay
        function hideDropdownOverlay() {
            const overlay = document.getElementById('dropdown-overlay');
            if (overlay) {
                overlay.classList.remove('visible');
                overlay.classList.add('hidden');
            }
        }

        // Handle row clicks
        var rowClicked = (event) => {
            // Don't fire row clicked if clicking on checkbox or dropdown elements
            if (event.target.closest('sl-checkbox') || event.target.tagName === 'SL-CHECKBOX' ||
                event.target.closest('sl-dropdown') || event.target.closest('.menu-column')) {
                return;
            }

            let row = event.currentTarget;
            const rowId = parseInt(row.getAttribute('data-row-id'));

            // Find the corresponding full data entry from tableData array
            const rowData = tableData.find(item => item.id === rowId);

            if (rowData) {
                console.log('Row clicked - Full table data entry:', rowData);
            } else {
                console.log('Row clicked but data not found for ID:', rowId);
            }
        };

        // Function to create sort indicator SVG
        function createSortIndicator(sortable = false, direction = 'none') {
            if (!sortable) return '';

            const upColor = direction === 'asc' ? 'var(--sl-color-neutral-500)' : 'var(--sl-color-neutral-300)';
            const downColor = direction === 'desc' ? 'var(--sl-color-neutral-500)' : 'var(--sl-color-neutral-300)';

            return `
                <span class="sort-indicator">
                    <svg width="10" height="16" viewBox="0 0 10 16" class="sort-svg">
                        <polygon points="5,3 1,7 9,7" fill="${upColor}" />
                        <polygon points="5,13 1,9 9,9" fill="${downColor}" />
                    </svg>
                </span>
            `;
        }

        // Helper: rebuild <colgroup> widths based on visible columns + fixed leading columns
        function rebuildColgroup() {
            const table = document.getElementById('data-table');
            if (!table) return;
            let colgroup = table.querySelector('colgroup');
            if (!colgroup) {
                colgroup = document.createElement('colgroup');
                table.insertBefore(colgroup, table.firstChild);
            }
            colgroup.innerHTML = '';
            // Fixed columns: checkbox + menu
            const colCheckbox = document.createElement('col');
            colCheckbox.setAttribute('data-fixed', 'checkbox');
            colCheckbox.style.width = '44px';
            colgroup.appendChild(colCheckbox);
            const colMenu = document.createElement('col');
            colMenu.setAttribute('data-fixed', 'menu');
            colMenu.style.width = '44px';
            colgroup.appendChild(colMenu);

            const visibleColumns = getVisibleColumns();
            visibleColumns.forEach(col => {
                const c = document.createElement('col');
                c.setAttribute('data-column-key', col.key);
                if (col.width) {
                    c.style.width = typeof col.width === 'number' ? `${col.width}px` : String(col.width);
                } else {
                    c.style.width = '200px'; // Default width for columns without explicit width
                }
                colgroup.appendChild(c);
            });
        }

        // Function to create table headers dynamically
        function createTableHeaders() {
            const table = document.getElementById('data-table');
            if (!table) return false;

            const thead = table.querySelector('thead');
            if (!thead) return false;

            // Clear existing headers
            thead.innerHTML = '';

            // Ensure colgroup reflects current visible columns
            rebuildColgroup();

            // Create single header row with both header content and filters
            const headerRow = document.createElement('tr');

            // Add checkbox column with selection view toggle
            const checkboxHeader = document.createElement('th');
            checkboxHeader.className = 'checkbox-column';
            checkboxHeader.innerHTML = `
                <div class="header-cell-content">
                    <div id="selection-view-toggle" class="selection-view-toggle invisible">
                        <sl-tooltip hoist content="">
                            <div class="selection-view-toggle-btn-wrapper">
                                <sl-icon-button id="selection-view-toggle-btn" name="funnel" size="small" title=""></sl-icon-button>
                                <sl-icon id="selection-view-badge" class="selection-view-badge selection-view-badge-hidden" name="" ></sl-icon>
                            </div>
                        </sl-tooltip>
                    </div>
                </div>
                <div>
                    <sl-checkbox id="header-select-all"></sl-checkbox>
                </div>
            `;
            headerRow.appendChild(checkboxHeader);

            // Add menu column
            const menuHeader = document.createElement('th');
            menuHeader.className = 'menu-column';
            headerRow.appendChild(menuHeader);

            // Get visible columns
            const visibleColumns = getVisibleColumns();

            // Add column headers from visible definitions
            visibleColumns.forEach((col, index) => {
                const th = document.createElement('th');
                if (col.className) {
                    th.className = col.className;
                }

                th.style.textAlign = 'left';

                // Set minimum width for boolean columns to accommodate ordering controls
                if (col.type === 'boolean') {
                    th.style.minWidth = '140px';
                }

                // Add data attribute for column identification
                th.setAttribute('data-column-key', col.key);

                // Create header content (title, sort indicator, ordering controls)
                let headerContent = `
                    <div class="header-cell-content">
                        <div class="column-header-content">
                            ${col.title}
                            ${createSortIndicator(col.sortable, col.sortDirection)}
                        </div>
                        <div class="column-ordering-controls">
                            ${index > 0 ? `<sl-icon-button name="arrow-left" size="small" class="move-column-left" data-column-key="${col.key}" title="Move left"></sl-icon-button>` : ''}
                            ${index < visibleColumns.length - 1 ? `<sl-icon-button name="arrow-right" size="small" class="move-column-right" data-column-key="${col.key}" title="Move right"></sl-icon-button>` : ''}
                        </div>
                    </div>
                `;

                // Create filter content
                let filterContent = '<div class="filter-cell-content">';
                if (col.filterable) {
                    const inputId = `filter-${col.key}`;
                    if (col.type === 'boolean') {
                        // Use dropdown for boolean columns
                        filterContent += `
                            <sl-dropdown hoist placement="bottom" style="width: 100%;">
                                <sl-button slot="trigger" size="small" variant="default" id="${inputId}" data-column-key="${col.key}" style="width: 100%; justify-content: space-between;">
                                    Všechny<sl-icon name="chevron-down" slot="suffix"></sl-icon>
                                </sl-button>
                                <sl-menu>
                                    <sl-menu-item data-value="">Všechny</sl-menu-item>
                                    <sl-menu-item data-value="true">Ano</sl-menu-item>
                                    <sl-menu-item data-value="false">Ne</sl-menu-item>
                                </sl-menu>
                            </sl-dropdown>
                        `;
                    } else {
                        // Use text input for other column types
                        filterContent += `
                            <sl-input id="${inputId}" size="small" placeholder="${col.filterPlaceholder}" autocomplete="off" data-column-key="${col.key}" style="width: 100%;"></sl-input>
                        `;
                    }
                }
                filterContent += '</div>';

                th.innerHTML = headerContent + filterContent + '<span class="col-resizer" data-column-key="' + col.key + '"></span>';

                headerRow.appendChild(th);
            });

            // Add event listeners for column ordering buttons and sorting on header click
            headerRow.addEventListener('click', (event) => {
                // Ignore clicks during/after resizing
                if (isResizing) {
                    event.preventDefault();
                    event.stopPropagation();
                    return;
                }
                if (lastResizeEnd && performance.now() - lastResizeEnd < 300) {
                    event.preventDefault();
                    event.stopPropagation();
                    return;
                }
                // Handle move column buttons first (clicks might land on nested elements)
                const moveLeftBtn = event.target.closest('.move-column-left');
                const moveRightBtn = event.target.closest('.move-column-right');
                if (moveLeftBtn) {
                    event.preventDefault();
                    event.stopPropagation();
                    const columnKey = moveLeftBtn.getAttribute('data-column-key');
                    moveColumnLeft(columnKey);
                    return;
                }
                if (moveRightBtn) {
                    event.preventDefault();
                    event.stopPropagation();
                    const columnKey = moveRightBtn.getAttribute('data-column-key');
                    moveColumnRight(columnKey);
                    return;
                }

                // Otherwise, toggle sort if clicking on a sortable header cell
                const headerCellContent = event.target.closest('.header-cell-content');
                if (!headerCellContent) return;

                const th = headerCellContent.closest('th');
                if (!th) return;

                const columnKey = th.getAttribute('data-column-key');
                if (!columnKey) return;

                const colDef = columnDefinitions.find(c => c.key === columnKey);
                if (!colDef || !colDef.sortable) return;

                toggleSort(columnKey);
            });

            thead.appendChild(headerRow);

            // Wire resizer handles
            wireResizers(thead);

            // Delegated hover handling across entire thead
            setupTheadHover(thead);

            // Add event handlers for filter inputs and dropdowns
            const filterInputs = headerRow.querySelectorAll('sl-input[data-column-key]');
            const filterDropdowns = headerRow.querySelectorAll('sl-dropdown sl-button[data-column-key]');

            // Handle text inputs
            filterInputs.forEach(input => {
                const columnKey = input.getAttribute('data-column-key');

                // Handle input events for filtering
                input.addEventListener('input', (event) => {
                    const filterValue = event.target.value;
                    setColumnFilter(columnKey, filterValue);
                });

                // Handle focus to select all content
                input.addEventListener('focus', (event) => {
                    // Use setTimeout to ensure the focus event completes first
                    setTimeout(() => {
                        event.target.select();
                    }, 0);
                });

                // Handle escape key to clear filter
                input.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        event.target.value = '';
                        setColumnFilter(columnKey, '');
                    }
                });

                // Restore filter value if it exists
                if (columnFilters[columnKey]) {
                    input.value = columnFilters[columnKey];
                }
            });

            // Handle dropdown filters
            filterDropdowns.forEach(button => {
                const columnKey = button.getAttribute('data-column-key');
                const dropdown = button.closest('sl-dropdown');
                const menu = dropdown.querySelector('sl-menu');

                // Handle menu selection
                menu.addEventListener('sl-select', (event) => {
                    const selectedValue = event.detail.item.getAttribute('data-value');
                    const selectedText = event.detail.item.textContent;

                    // Update button text
                    button.innerHTML = `${selectedText}<sl-icon name="chevron-down" slot="suffix"></sl-icon>`;

                    // Apply filter
                    setColumnFilter(columnKey, selectedValue);
                });

                // Restore filter value if it exists
                if (columnFilters[columnKey]) {
                    const currentValue = columnFilters[columnKey];
                    const menuItem = menu.querySelector(`sl-menu-item[data-value="${currentValue}"]`);
                    if (menuItem) {
                        const selectedText = menuItem.textContent;
                        button.innerHTML = `${selectedText}<sl-icon name="chevron-down" slot="suffix"></sl-icon>`;
                    }
                } else {
                    // No filter applied, show default "Všechny"
                    button.innerHTML = 'Všechny<sl-icon name="chevron-down" slot="suffix"></sl-icon>';
                }
            });

            // Wire header select-all checkbox
            const headerSelect = document.getElementById('header-select-all');
            if (headerSelect) {
                headerSelect.addEventListener('sl-change', handleHeaderCheckboxChange);
                // Initialize its tri-state state
                updateHeaderCheckboxState();
            }

            // Wire selection view toggle button
            const viewToggleBtn = document.getElementById('selection-view-toggle-btn');
            if (viewToggleBtn) {
                viewToggleBtn.addEventListener('click', () => {
                    // Cycle modes only if at least one row is selected
                    if (selectedRowIds.size === 0) return;
                    selectionViewMode = selectionViewMode === 'all' ? 'selected' : selectionViewMode === 'selected' ? 'unselected' : 'all';
                    currentPage = 1; // reset pagination when mode changes
                    populateTableRows();
                    updatePaginationUI();
                    updateSelectionViewToggleUI();
                });
            }

            // Initialize selection view toggle UI state
            updateSelectionViewToggleUI();

            return true;
        }

        // Function to populate only table rows (tbody) - used for filtering/pagination
        function populateTableRows() {
            const table = document.getElementById('data-table');
            if (!table) {
                return false;
            }

            const tbody = table.querySelector('tbody');
            if (!tbody) {
                return false;
            }

            // Clear existing rows
            tbody.innerHTML = '';

            // Get visible columns
            const visibleColumns = getVisibleColumns();

            // Get current page data for pagination
            const currentPageData = getCurrentPageData();

            // Check if there's no data to display
            if (currentPageData.length === 0) {
                const tr = document.createElement('tr');
                tr.className = 'no-data-row';

                const td = document.createElement('td');
                td.colSpan = visibleColumns.length + 2; // +2 for checkbox and menu columns
                td.textContent = 'Nenalezeny žádné záznamy';
                td.className = 'no-data-row';

                tr.appendChild(td);
                tbody.appendChild(tr);
            } else {
                // Add actual data rows (paginated)
                currentPageData.forEach((row, index) => {
                    const tr = document.createElement('tr');

                    // Store the row ID as a data attribute for later retrieval
                    tr.setAttribute('data-row-id', row.id);

                    // Add checkbox cell
                    const checkboxCell = document.createElement('td');
                    checkboxCell.innerHTML = '<sl-checkbox class="row-select"></sl-checkbox>';
                    const rowCheckbox = checkboxCell.querySelector('sl-checkbox');
                    // Set checked state from selection set
                    rowCheckbox.checked = selectedRowIds.has(row.id);
                    rowCheckbox.addEventListener('sl-change', (e) => {
                        handleRowCheckboxChange(row.id, e.target.checked);
                        // Stop the row click from firing
                        e.stopPropagation();
                    });
                    tr.appendChild(checkboxCell);

                    // Add menu cell with dropdown
                    const menuCell = document.createElement('td');
                    menuCell.className = 'menu-column';

                    const dropdownId = `row-menu-${row.id}`;
                    const menuItems = menuActions.map(action =>
                        `<sl-menu-item data-action="${action.actionName}">${action.label}</sl-menu-item>`
                    ).join('');

                    menuCell.innerHTML = `
                    <sl-dropdown hoist id="${dropdownId}">
                        <sl-button slot="trigger" size="small" variant="text" circle>
                            <sl-icon name="three-dots-vertical"></sl-icon>
                        </sl-button>
                        <sl-menu>
                            ${menuItems}
                        </sl-menu>
                    </sl-dropdown>
                `;
                    tr.appendChild(menuCell);

                    // Add event listener for menu selection
                    const dropdown = menuCell.querySelector('sl-dropdown');
                    const menu = dropdown.querySelector('sl-menu');

                    // Handle dropdown show/hide with overlay
                    dropdown.addEventListener('sl-show', () => {
                        // Close any other open dropdown first
                        if (currentOpenDropdown && currentOpenDropdown !== dropdown) {
                            currentOpenDropdown.hide();
                        }

                        currentOpenDropdown = dropdown;
                        showDropdownOverlay();
                    });

                    dropdown.addEventListener('sl-hide', () => {
                        currentOpenDropdown = null;
                        hideDropdownOverlay();
                    });

                    menu.addEventListener('sl-select', (event) => {
                        const actionName = event.detail.item.getAttribute('data-action');
                        const action = menuActions.find(a => a.actionName === actionName);
                        if ( action) {
                            rowMenuItemSelected(action, row);
                        }
                    });

                    // Add data cells based on visible column definitions
                    visibleColumns.forEach(col => {
                        const td = document.createElement('td');

                        // Apply text alignment
                        if (col.align) {
                            td.style.textAlign = col.align;
                        }

                        // Set minimum width for boolean columns to accommodate ordering controls
                        if (col.type === 'boolean') {
                            td.style.minWidth = '140px';
                        }

                        // Use Shoelace format components for special columns
                        if (col.key === 'turnover') {
                            td.innerHTML = `<sl-format-number value="${row[col.key]}" type="decimal" minimum-fraction-digits="2" maximum-fraction-digits="2"></sl-format-number>`;
                        } else if (col.key === 'contractDate') {
                            td.innerHTML = `<sl-format-date date="${row[col.key]}"></sl-format-date>`;
                        } else if (col.key === 'approved') {
                            const checkedAttr = row[col.key] ? 'checked' : '';
                            td.innerHTML = `<sl-switch ${checkedAttr} disabled></sl-switch>`;
                        } else {
                            td.textContent = row[col.key];
                        }

                        tr.appendChild(td);
                    });



                    // Add row click handler
                    tr.addEventListener('click', rowClicked);

                    tbody.appendChild(tr);
                });
            }

            // After rows are rendered, update header tri-state and selection menu UI
            updateHeaderCheckboxState();
            updateSelectionMenuUI();
            updateSelectionViewToggleUI();
            return true;
        }

        // Full table population function - creates headers and rows
        function populateTable() {
            console.log('populateTable called');
            // Find table using specific ID
            const table = document.getElementById('data-table');
            if (!table) {
                return false;
            }

            // Create headers dynamically
            if (!createTableHeaders()) {
                return false;
            }

            // Populate rows
            if (!populateTableRows()) {
                return false;
            }

            // Update pagination UI after populating table
            updatePaginationUI();

            return true;
        }

        // Initialize table with retry logic
        function initializeTable() {
            console.log('initializeTable called');
            // set preselected columns visibility in columns definitions
            columnDefinitions.forEach(col => {
                if (unshowableColumns.includes(col.key)) {
                    // Unshowable columns are always hidden
                    col.visible = false;
                } else if (preselectedColumns.includes(col.key) || unhideableColumns.includes(col.key)) {
                    col.visible = true;
                } else {
                    col.visible = false;
                }
            });

            // Normalize sort state: ensure at most one active sort (prefer first visible one)
            const activeSorts = columnDefinitions.filter(c => c.sortable && c.sortDirection && c.sortDirection !== 'none');
            if (activeSorts.length > 1) {
                // Keep the first visible by order, otherwise the first in list
                const firstVisible = columnDefinitions
                    .filter(c => c.visible && c.sortable && c.sortDirection && c.sortDirection !== 'none')
                    .sort((a, b) => a.order - b.order)[0];
                const keepKey = (firstVisible || activeSorts[0]).key;
                clearOtherSorts(keepKey);
            }

            // Initialize filtered data
            filteredData = tableData.slice(); // Start with all data

            // Configure column selector component
            const columnSelector = document.getElementById('column-selector');
            if (columnSelector) {
                columnSelector.setColumnDefinitions(columnDefinitions);
                columnSelector.setColumnFilters(columnFilters);
                columnSelector.setUnshowableColumns(unshowableColumns);
                columnSelector.setUnhideableColumns(unhideableColumns);

                // Configure column selector event listeners
                columnSelector.addEventListener('column-visibility-changed', (event) => {
                    const { columnKey, visible } = event.detail;
                    console.log('Column visibility changed:', columnKey, visible);
                    populateTable();
                });

                columnSelector.addEventListener('clear-filters', () => {
                    console.log('Clear all filters');
                    clearAllFilters();
                });

                columnSelector.addEventListener('select-all-columns', () => {
                    console.log('Select all columns');
                    selectAllColumns();
                });

                columnSelector.addEventListener('clear-all-columns', () => {
                    console.log('Clear all columns');
                    clearAllColumns();
                });
            }

            // Add pagination event listeners on footer component
            const footer = document.getElementById('table-footer');
            if (footer) {
                footer.addEventListener('page-size-changed', (event) => {
                    changeItemsPerPage(event.detail.pageSize);
                });
                footer.addEventListener('page-changed', (event) => {
                    goToPage(event.detail.page);
                });
            }

            // Initialize dropdown overlay
            initializeDropdownOverlay();

            // Add global keyboard shortcuts
            document.addEventListener('keydown', (event) => {
                // Ctrl+Shift+C to clear all filters
                if (event.ctrlKey && event.shiftKey && event.key === 'C') {
                    event.preventDefault();
                    clearAllFilters();
                }
            });

            // Wire Export to Excel button
            const exportBtn = document.getElementById('export-excel-btn');
            if (exportBtn) {
                exportBtn.setExportData(() => ({
                    tableData,
                    columnDefinitions,
                    selectedRowIds,
                    columnFilters,
                    getVisibleColumns: getVisibleColumns,
                    filteredData,
                    getSortedActiveData: () => getSortedData(getActiveData())
                }));
            }

            // Wire Import from Excel button
            const importBtn = document.getElementById('import-excel-btn');
            if (importBtn) {
                importBtn.setImportData(() => ({
                    columnDefinitions
                }));
                // Listen for import-row events
                importBtn.addEventListener('import-row', (event) => {
                    // Handle imported row - this could update the table data
                    console.log('Imported row:', event.detail.row);
                });
            }
        }

        // Update selection view toggle (icon, tooltip, and visibility)
        function updateSelectionViewToggleUI() {
            const container = document.getElementById('selection-view-toggle');
            const btn = document.getElementById('selection-view-toggle-btn');
            const tooltip = container ? container.querySelector('sl-tooltip') : null;
            const badge = document.getElementById('selection-view-badge');
            if (!container || !btn) return;

            const selectedCount = selectedRowIds.size;
            if (selectedCount === 0) {
                // Reset mode to all when nothing is selected and hide control
                if (selectionViewMode !== 'all') {
                    selectionViewMode = 'all';
                    // Rows may need to be repopulated if we were previously filtered
                    populateTableRows();
                    updatePaginationUI();
                }
                container.classList.add('invisible');
                if (badge) badge.classList.add('selection-view-badge-hidden');
                return;
            }

            // Show control
            container.classList.remove('invisible');

            // Update tooltip/title based on current mode
            let label = '';
            if (selectionViewMode === 'all') {
                label = 'Režim zobrazení: všechny řádky';
                if (badge) badge.classList.add('selection-view-badge-hidden');
            } else if (selectionViewMode === 'selected') {
                label = 'Režim zobrazení: jen vybrané řádky';
                if (badge) {
                    badge.classList.remove('selection-view-badge-hidden');
                    badge.name = 'check';
                    badge.style.color = 'var(--sl-color-success-600)';
                }
            } else {
                label = 'Režim zobrazení: jen nevybrané řádky';
                if (badge) {
                    badge.classList.remove('selection-view-badge-hidden');
                    badge.name = 'x';
                    badge.style.color = 'var(--sl-color-danger-600)';
                }
            }
            btn.title = label;
            if (tooltip) {
                tooltip.setAttribute('content', label);
            }
        }

        // Handle new-record event from the web component
        var createRecordButton = document.querySelector('ts-create-record-button');
        if (createRecordButton) {
            createRecordButton.addEventListener('new-record', () => {
                alert('New record event was fired');
            });
        }

        // Handle do-import event from the web component
        var importButton = document.querySelector('ts-import-button');
        if (importButton) {
            importButton.addEventListener('do-import', (event) => {
                const { importData, file } = event.detail;
                console.log('Import data received:', importData);
                
                // Process import data (dummy logic for now)
                let added = 0, updated = 0, rejected = 0, skipped = 0;
                const rejectedRows = [];
                const rejectedRowsData = [];
                
                importData.forEach(({ __index, data }) => {
                    // Dummy decision: alternate status for preview
                    const mod = __index % 4;
                    if (mod === 1) added++;
                    else if (mod === 2) updated++;
                    else if (mod === 3) { 
                        rejected++; 
                        rejectedRows.push(__index); 
                        rejectedRowsData.push(data); 
                    }
                    else skipped++;
                });

                // Store rejected data for saving
                importButton.rejectedRowsData = rejectedRowsData;

                // Show results via the web component
                importButton.showImportResults({
                    added,
                    updated,
                    rejected,
                    skipped,
                    rejectedRows
                });
            });
        }

        // Handle selection-action-activated event from the web component
        var selectionMenu = document.getElementById('selection-menu');
        if (selectionMenu) {
            selectionMenu.addEventListener('selection-action-activated', (event) => {
                const action = event.detail.action;
                const selectedRows = event.detail.selectedRows;
                console.log('Selection action activated:', action, 'with selected rows:', selectedRows);
            });

            // Handle unselect-all-rows event from the web component
            selectionMenu.addEventListener('unselect-all-rows', (event) => {
                console.log('Unselecting all rows');
                // Clear all selected rows
                selectedRowIds.clear();
                // Update table display
                populateTableRows();
                updatePaginationUI();
                // Update UI
                updateSelectionMenuUI();
                // Hide the selection menu
                selectionMenu.hide();
                // Remove focus from the menu to avoid aria violations
                if (document.activeElement) {
                    document.activeElement.blur();
                }
            });
        }

        initializeTable();

        // Initialize table display
        populateTable();

    </script>
    <div id="container">
        <!-- DATATABLE -->
        <!-- Toolbar -->
        <div class="toolbar">
            <div>
                <ts-create-record-button></ts-create-record-button>
            </div>
            <div class="toolbar-center">
                <ts-selection-menu id="selection-menu" single-item-actions="edit/Upravit záznam,duplicate/Duplikovat záznam,delete/Smazat záznam" multiple-items-actions="delete/Smazat vybrané,export/Exportovat vybrané"></ts-selection-menu>
                <ts-import-button id="import-excel-btn"></ts-import-button>
                <ts-export-button id="export-excel-btn"></ts-export-button>
            </div>
            <div>
                <ts-column-selector id="column-selector"></ts-column-selector>
            </div>
        </div>
        <!-- FOOTER -->
            <table id="data-table">
                <thead>
                    <!-- Headers will be created dynamically by createTableHeaders() function -->
                </thead>
                <tbody>
                    <!-- Table rows will be populated dynamically by populateTable() function -->
                </tbody>
            </table>
            <!-- Loading overlay for filtering positioned over table body area -->
            <div id="table-loading-overlay" class="table-loading-overlay hidden">
            </div>
        </div>
        <!-- FOOTER -->
        <ts-table-pager id="table-footer"></ts-table-pager>
        <!-- Dropdown overlay for modal behavior -->
        <div id="dropdown-overlay" class="dropdown-overlay hidden"></div>
    </div>
</div>
